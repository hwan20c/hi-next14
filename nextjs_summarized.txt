react는 라이브러리
라이브러리 
-> 코드에서 사용 되는 것(사용의 주체는 개발자) 
-> 개발자가 다운 받아서 사용하는 것

next는 프레임워크
프레임워크 
-> 코드를 사용하는 주체(개발자에겐 권한이 없다.) 
-> 프레임워크는 프로젝트의 틀(frame) 같은 걸 지정해주는 경우들이 대부분이다.
-> 코드를 올바른 위치에 넣으면 프레임워크가 동작하게 해준다.

---------------------------------------------------------------------------

next에서 특별한 파일명은

layout.~ 
page.~ 
not-found.~ 

등이 있다.

---------------------------------------------------------------------------

next는

app폴더 밑에 page.tsx or .jsx 파일이 있다면, 저절로 layout.tsx나 .jsx 파일을 만들어서 동작하게 해준다.
layout.~ 파일은 지워도 저절로 next가 자동 생성해준다.

page.tsx는 root segment라고 불린다.

next js는 폴더명으로 알아서 routing을 해준다.
예를들어 app밑에 about-us폴더를 만들고 그안에 page.tsx를 만들면
/about-us 주소로 접근이 가능하다.

폴더안에 폴더를 만들어서 그안에 또 page.tsx파일을 만들면 
폴더명대로 라우팅이 된다.
예를들어 about-us/company/sales 밑에 page.tsx를 만들면
주소접근시에 /about-us/company/sales로 접근이 가능해진다.


---------------------------------------------------------------------------

csr과 ssr의 차이

usePathname을 사용하기 위해서는 "use client"; 라는 글자를 .tsx파일 맨위에 올려줘야한다.

rendering -> react code를 브라우저가 이해할 수 있는 html로 바꾸는 것

react가 rendering하는 방식은 csr(client side rendring)이다. -> 브라우저가 rendering하는것 

csr의 단점 
1. 자바스크립트가 동작하고 나서 렌더링이 되는 문제
-> 자바스크립트가 대부분의 것을 다운로드 한 다음에 동작(화면이 보여지게)하게 된다. 
-> 랜더링이 될때까지 시간이 걸리기 때문에, 페이지를 호출할시 하얀화면(빈페이지)을 보고 시작하는 경우들이 대부분이다.
-> 자바스크립트를 비활성화 하면 렌더링 자체가 되지 않는다.
-> 통신이 잘 안 되는 지역에서는 렌더링이 될때까지 오래걸릴 가능성이 있다.

2. seo 검색 엔진 최적화가 힘들다.
-> google같은 검색엔진에서 노출되기 원한다면 google은 html을 읽어서 검색엔진을 만들기 때문에 웹사이트가 노출되는 경우가 줄어들 가능성이 있다.(화면에 접근하지 않으면 하얀화면(빈페이지)를 나타내기 때문이다. -> 빈페이지를 접근하게 된다. -> 검색이 안됌.)

아무런 프레임 워크 없이 create-react-app으로 설치해 서버를 올린다면 csr가 되어 버린다.

반면에, 

next는 자동적으로 ssr(server side rendering)을 하게 끔 되어 있다.
-> 화면에 표시할 html을 javascript랑은 상관없이 먼저 보여줄 수 있다.
-> next.js 안에 모든 page의 컴포넌트들을 우선 server에서 rending하는 거다.
-> backend에서 먼저 올라간다.
-> 주의해야할점은 모든 컴포넌트에 대해서 발생한다는 점이다.
-> next.js에서 "use client"; 라는걸 썼다고, csr로 작동하는것이 아니다.

---------------------------------------------------------------------------

hydrated

dehydrated는 탈수된 이라는 뜻이다. 그렇다면 hydrated는 반대의 수분이 가득찬 이라는 뜻을 갖는다.

hydration -> 유저가 최초 html을 보고 나서 부터의 일들을 뜻하는 말(단순 html을 React application으로 초기화 하는 작업)
-> html을 보고난 후부터 React가 로드되고, components가 로드되고 initialize가 된다.
-> 그러면 app은 react js app이 되어 버리는거다.

js를 비활성화 해서 하면 그냥 새로고침을 해서 anchors로 페이지로 이동하는거 처럼 보이지만, js를 활성화하면 새로고침이 아니라 그냥 페이지를 이동하는것처럼 보인다.
-> 이는 react가 hydrated된 것이다.
-> 처음에는 anchors 묶음 이였다가. react component로 변하면서 생기는 과정이다.(Link component가 활성화 되기 때문)


동작과정
-> 누군가가 /about-us 페이지로 접근하기 원하면 next 서버는 component를 dummy html로 요청해서 뿌려준다.
-> 이 사용자가 /about-us를 동작하는 즉시, 프레임워크(next.js)는 load를 시작한다.
-> 바로 html을 초기화 하면서 React application을 로드를 하는것이다.
-> 그러면 이제 achors 태그들이 react의 link태그의 동작으로 바뀌게 되고
-> 페이지 이동시에 새로고침 할 필요 없이 로드가 되는 것이다.


혹시 자바스크립트가 로드 되는데 굉장히 오래 걸리면, 일단은 기본적인 html의 동작으로 실행은 될 것이다.

----------------------------------------------------------------------------------------

"use client"

hydration과정은 프로젝트 내의 모든 components들에 대해서 발생되지는 않는다.
-> ssr을 모든 components에 대해서 발생하지만 말이다.
-> client에서 hydration가 되는 components들은 "use client"라는 키워드를 가진 components에서만 동작한다.
-> 이게 use client를 넣는 이유가 된다.
-> 언제 써야할지는 에러를 봐서 적용하면된다.(use client가 필요한 키워드들이 있다.)

"server components"
-> "use client"를 사용하지 않는 모든 것들에 대해서 말한다.


이렇게 나눠지는것은 page마다 js를 로드할 필요가 없게 하기 위해서이다.
필요한 곳에서만 로드할 수 있게 하는 것이 굉장히 좋은 방식이라 볼 수 있다.

----------------------------------------------------------------------------------------\

정리

next.js가 제일 처음 하는일
-> 사용자에게 응답이 주어지기전에 백엔드에서 어플리케이션을 프리랜더링을 한다.
-> 모든 컴포넌트를 가져가서 노말 html으로 바꾼다. 
-> 그걸 사용자에게 준다.
-> 사용자가 도착하면 프레임워크와 React.js를 초기화한다.
-> 그리고 use client 를 가진 component들이 hydrate된다.
-> next의 예전 버전들과는 다르게 use client를 가진 컴포넌트들만 hydrate된다.
-> 필요한 곳에서만 hydrate되기 때문에, 클라이언트들이 js파일을 조금만 받아도 되는 장점이 있다.
-> server component 안에 client component를 가질 수 있다. 그라나 반대는 안된다.
-> server component는 db와 같은 정적인 데이터들을 바로 가져올 수 있는 장점이 있다.

----------------------------------------------------------------------------------------

layout

layout안에서 컴포넌트(children)를 불러오는 형식으로 진행하는건 리액트의 기술중 하나이다.
children: React.ReactNode -> tsx이기때문에 존재하는 값
그러므로 모든페이지의 공통적인 요소를 넣을때에는 layout.tsx에 넣어주는게 좋다.
layout.tsx는 어떠한 폴더에서 만들면 그 폴더내에서 전체적으로 공통적인 요소를 작용하는게 된다.
-> 하위폴더까지 다 적용된다.(기존의 layout처럼)
layout은 중첩이 가능하다. -> 있는대로 다 적용된다.

----------------------------------------------------------------------------------------

route groups
-> 폴더를 만들때 ()로 해야한다.
-> ()되면 next가 스스로 페이지를 생성하지 않는다.(URL에 영향을 주지 않는다.)

metadata
-> 꼭 내보내야 하는 object들이다.
-> 각각의 페이지에서 설정 할 수 있다.
-> 컴포넌트에서는 metadata를 내보낼 수 없고 또 metadata는 서버 컴포넌트에서만 있을수 있다.
-> 최상위의 layout에서는 Metadata형 함수를 만들어서 %s로 각각의 페이지의 title값을 가져올 수 있게 한다.
-> metadata에는 여러가지 값들을 넣을 수 있다.(공식 문서에서 확인하면 된다.)

----------------------------------------------------------------------------------------

Dynamic Routes
-> 게시물 값에 따라서 바뀌는 route -> /movies/:id 같은것
-> 폴더를 만들때 []대괄호를 사용해서 만들면 Dynamic Route가 적용된다.
-> [] 안에 들어가는것을 key 지정하는것과 같다. 
예를들어 /movies/[id]로 되어있는 경로로 접근하는게 /movies/123444 이면 id : '123444'가 된다.(console.log(props)로 확인가능)
-> params와 searchParams로 받아지는값이 있다. 
-> searchParams도 ? 뒤에오는 파라미터로 값을 받아 올 수 있다.

----------------------------------------------------------------------------------------

metadata는 client component에서는 쓸 수 없다.

----------------------------------------------------------------------------------------

next는 original react처럼 useState나 useEffect로 fetch를 하지 않아도 server side에서 async await를 이용해서 json데이터를 불러오는 기능이 가능하다.
처음에 fetch한 data들을 caching하여 가지고 있기 때문에, 접근할때 마다 불러올 필요가 없어진다.

대신 server side에서 일어나야 되는일이 제대로 동작하지 않은 경우에는 page자체가 열리지 않게 된다.

----------------------------------------------------------------------------------------

loading.tsx 
-> 를 만들면 백엔드에서 기능들이 다 완료 될때까지 도와주는 페이지(로딩 페이지)를 적용시킬 수 있다.
-> page.tsx가 있는 같은 경로에 넣어줘야 그 경로에 대한게 동작한다.

----------------------------------------------------------------------------------------

병렬로 fetching 하는법

// 따로 따로 결과값을 받게 해서 비동기 적으로 수행할 수 있게 만들어주는것이다. -> 그렇지 않으면 앞에 fetching을 기다려야 하기 때문에 앞에가 끝나지 않으면 뒤에 fetching이 진행이 안되기 때문이다.
  const [movie, viedos] = await Promise.all([getMovie(id), getvideos(id)]);
-> 하지만 위와 같은 코드에도 문제가 있는게, 앞에 code로 fetching이 될때까지 ui는 안 보여 지는 이슈가 생겨 버린다.

그래서 fetching하는 기능들을 각각의 서버사이드쪽 컴포넌트로 만들어 버린 다음에

    <div>
      <Suspense fallback={<h1>Loading movie info</h1>}>
        <MovieInfo id={id} />
      </Suspense>
      <Suspense fallback={<h1>Loading movie videos</h1>}>
        <MovieVideos id={id} />
      </Suspense>
    </div>

이런식으로 <Suspense> 라는 react에 있는 tag를 사용하면 따로 따로 랜더링이 되는걸 확인 할 수 있다.

이렇게 return안에 Suspense만 있는 경우에는 loading.tsx가 동작하지 않는다.(Suspense는 따로 동작하기 때문이다.)


----------------------------------------------------------------------------------------


next의 error 처리 페이지는 error.tsx를 넣어주면 처리가 된다.